# Домашние задания по курсу углубленного программирования на C++

## 00 - Сумма двумерного массива
  Написать две программы, суммирующие элементы двумерного массива (матрицы) целых чисел.
  Одна программа суммирует по столбцам, вторая - по строкам. 
  Измерить время работы в обоих случаях, сравнить результаты. 
  Для замеров можно использовать класс Timer.
  
## 01 - Калькулятор

  Используя метод рекурсивного спуска, написать калькулятор. Поддерживаемые операции:

  * умножение
  * деление
  * сложение
  * вычитание
  * унарный минус
  
  Для вычислений использовать тип int, приоритет операций стандартный.
  Передача выражения осуществляется через аргумент командной строки, 
  поступаемые числа целые, результат выводится в cout. 
  
  Пример:
```
  calc "2 + 3 * 4 - -2"
```
  Вывод:
```
  16
```

  Должна быть обработка ошибок, в случае некорректного выражения выводить в консоль ошибку и возвращать код отличный от 0.
  Тесты обязательны.

## 02 - Линейный аллокатор

  Написать свой аллокатор со стратегией линейного выделения памяти со следующим интерфейсом:
```
  class LinearAllocator
  {
  public:
      LinearAllocator(size_t maxSize);
      char* alloc(size_t size);
      void reset();
  };
```

  Аллокатор при создании аллоцирует указанный размер,
  после чего при вызове alloc возвращает указатель на блок запрошенного размера 
  или nullptr, если места недостаточно. 
  После вызова reset аллокатор позволяет использовать свою память снова.

## 03 - Матрица

  Нужно написать класс-матрицу, тип элементов int.
  В конструкторе задается количество рядов и строк.
  Поддерживаются оперции: 
   * получить количество строк(rows)/столбцов(columns) 
   * получить конкретный элемент 
   * умножить на число(*=) 
   * сравнение на равенство/неравенство 

  В случае ошибки выхода за границы бросать исключение:
```
  throw std::out_of_range("")
```
  Пример:
```
  const size_t rows = 5;
  const size_t cols = 3;

  Matrix m(rows, cols);

  assert(m.getRows() == 5);
  assert(m.getColumns() == 3);

  m[1][2] = 5; // строка 1, колонка 2
  double x = m[4][1];

  m *= 3; // умножение на число

  Matrix m1(rows, cols);

  if (m1 == m)
  {
  }
```

## 04 - Big Integer

  Написать класс для работы с большими целыми числами. 
  Размер числа ограничен только размером памяти. 
  Нужно поддержать семантику работы с обычным int:
```
  BigInt a = 1;
  BigInt b = a;
  BigInt c = a + b + 2;
```
  Реализовать:
  * оператор вывода в поток
  * сложение
  * вычитание
  * унарный минус
  * все операции сравнения.

  std::vector и другие контейнеры использовать нельзя - управляйте памятью сами.

## 05 - Сериализатор

  Простой сериализатор поддерживающий два типа: uint64_t и bool.
  
```
    struct Data
  {
      uint64_t a;
      bool b;
      uint64_t c;
  };

  Data x { 1, true, 2 };

  std::stringstream stream;

  Serializer serializer(stream);
  serializer.save(x);

  Data y { 0, false, 0 };

  Deserializer deserializer(stream);
  const Error err = deserializer.load(y);

  assert(err == Error::NoError);

  assert(x.a == y.a);
  assert(x.b == y.b);
  assert(x.c == y.c);
```

  Сериализовать в текстовый вид с разделением пробелом, bool сериализуется как true и false

## 06 - Format

Написать функцию для форматирования строки, 
поддерживаться должен любой тип, который может быть выведен в поток вывода. 

Формат строки форматирования:
```
"{0} any text {1} {0}"
```
Номер в фигурных скобках - номер аргумента. 
Если аргументов меньше, чем число в скобках, 
и в случае прочих ошибок выбрасывать исключение std::runtime_error

Пример:
```
auto text = format("{1}+{1} = {0}", 2, "one");
assert(text == "one+one = 2");
```
Фигурные скобки - зарезервированный символ, если встречаются вне контекста {n} выбрасывать исключение std::runtime_error

## 07 - Vector

Написать свой контейнер Vector аналогичный std::vector,
аллокатор и итератор произвольного доступа для него. 
Из поддерживаемых методов достаточно:
* operator[]
* push_back, pop_back
* empty, size, clear
* begin, end, rbegin, rend
* resize
* reserve

## 08 - Threads

Создание потока - дорогая операция, поэтому иногда хочется этого избежать.

Идея:

- Создаем N потоков, каждый поток либо выполняет задачу, либо спит
- Новая задача добавляется в очередь, при этом происходит оповещение спящих потоков
- Проснувшись поток проверяет, что в очереди есть задача, после чего извлекает ее из очереди и выполняет
- Если задачи нет, поток засыпает ожидая оповещения


Реализовать пул потоков со следующим интерфейсом:
```
class ThreadPool
{
public:
    explicit ThreadPool(size_t poolSize);

     // pass arguments by value
    template <class Func, class... Args>
    auto exec(Func func, Args... args) -> std::future<decltype(func(args...))>;
};
```
Использование пула потоков:
```
struct A {};

void foo(const A&) {}

ThreadPool pool(8);

auto task1 = pool.exec(foo, A());
task1.get();

auto task2 = pool.exec([]() { return 1; });
task2.get();
```

## 09 - Multithreading sort

Выполнить сортировку бинарного файла содержащего числа uint64_t в 2 потока. 
Доступно 8 Мб памяти, больше выделять нельзя ни явно, ни неявно (например, в виде контейнеров),
при этом файл может быть размером превышающим доступную память. 
Пространство на диске можно считать бесконечным. 
Сортировку выполнять в новый файл.
